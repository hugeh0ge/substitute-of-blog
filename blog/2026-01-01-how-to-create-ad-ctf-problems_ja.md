「A&Dにおける作問」

# はじめに

この記事は[CTF Advent Calendar 2025](https://adventar.org/calendars/12609)の25日目の記事です。期限を大幅に超過してごめん。あけましておめでとう。

前回記事を書いてからすでに丸1年立とうとしていることに驚愕。
まあ元々最近はそんなにアウトプットしないようになっていたというのはありつつ、ICCの準備のせいでほぼ今年1年死んでいたというのも大きかった気がします。
ということでICCに関連して、A&Dの作問について話そうと思います。

思っていることを全部ダンプした結果、分量が大変なことになった。図表一切ないので読みづらいかもしれない。
今後図表とか、文章とか、追記するかも。

# 対象

この記事で対象になる読者は以下の条件を満たしているような方です。

- A&Dというルール形式が何か知っている。
- A&D CTFで作問をする予定がある。

おっと、ICCも終わって日本でA&D CTFが開かれることはもうないと思われるので、対象者がいなくなってしまいました。明日の記事は icchyr さんで「CTFの歴史（2010年代）」です。楽しみですね。
<!--  -->

[というわけにもいかないので、粛々と続きを書きます。](https://japlj.hatenablog.com/entry/2015/12/01/000210)

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

# A&D は本質的に壊れていて、終わっている

はい、実はこの記事において伝えたいことはこれだけです。
結論からいうと、A&Dというルール形式は、ほとんどの場合、プレイヤー側が問題に対する病的なカウンタープレイが可能であり、競技を成立させるためには、運営側がルールやシステムに強い制限をかけていくしかありません。あなたがA&D CTFを開いた場合、99%、あなたは作問ミスをするし、システムは何らかのバグを発現させ、discordは作問ミスやバグに関するチケットに溢れ、まともにプレイ可能な競技にはなりません。

### そもそも、一般にA&Dって成立していますか

「え、世の中には多くはないけどA&Dを採用しているCTFがあるじゃないか」と思った方もいるでしょう。厳しい水準で判断するならば、それらのCTFのほとんどは、まともな大会として成立していません。多くのプレイヤーは文句を言いませんが、それは競技をプレイできていなさすぎて問題を吟味することができておらず、気づいていないだけです。
そもそもA&Dは、チーム同士で攻撃と防御をしあう大会であるため、プレイヤーが楽しめる大会になるためには、チーム同士の強さのバランスがある程度拮抗している必要がありますし、例えば開始10分ですべての脆弱性がふさがれるような状況（すぐ"サチる"状況とでもいいましょうか）になってはいけません。すなわち、ある程度自動的にスケールし、どのような状況でも各プレイヤーが楽しめるJeopardyとは異なり、A&Dでは、競技時間の長さ、問題数、各問題の脆弱性の個数、各脆弱性利用の難易度、プレイヤー数、プレイヤーのスキルレベルなどのパラメータがあって、これらのバランスが取れていないと、楽しめる大会になりません。
オンラインのA&Dの大会では、多くのチームが参加して、それらのチームの強さは非常に様々です。結果として、大体同じぐらいのスキルレベルのチーム同士ではある程度試合になりますし、上位層から下位層まで、十分に攻撃も防御も行う機会があって、楽しみやすいでしょう。しかし、1位を取ろうとすると体験としては全く別物で、事前準備によってユニバーサルに適用可能な防御機構を作ったり、一番早く問題の根本的な破綻を見つけたチームが存在すれば、そのチームが圧倒的優位に立ちます。1チームでもそのようなチームがいた時点で、上位チームが取るべき戦略は、本来意図したような楽しいゲームプレイではなくなります。
オフラインの大会ではより状況は悪くなると言っていいでしょう。まずチーム数が非常に少なく、特に上位のチームは準備の面から全くもって気合の入りようが違います。プレイヤーが取ってくる戦略を吟味せず、下手に事前情報としてプラットフォームがどのようなものになるかなどをチームに提供してしまうと、最悪の場合、競技開始時点から、そのチームの脆弱性はすべて防がれているか緩和されていて全く攻撃できない、という状況にすらなりえます。A&Dは、プレイヤーが真剣にプレイし、戦略を突き詰めれば突き詰めるほど、まともな競技を成立させるのは難しいということが分かってきます。

実際、A&Dを採用していることで有名なDEFCON CTF Finalsでは、私が参加した限りではこれまで、私がこれから書くような懸念をすべて考慮した、十分なクオリティの問題は1問も無かったと思っています。そもそも毎年システムもバグり散らしているし。私は毎年、半分運ゲーだと思いながら、フラストレーションを貯めながら、参加していました（私は、2位を取った上でこの発言をしています）。
HITCON CTF Finalsでは、まともな問題がそれなりにあったような気もします（正直、こちらは自分の参加回数と吟味があまり足りてない）。それは上述のとおり、ルールやシステムに強い制限を掛けていたおかげです。彼らは例年、特にパッチにかなり強い制約を設けていましたが、私がこれから書くようなことを、運営の中で話しあい、熟慮した結果だと思っています。

と、ここまでですでに強い主張を書きましたが、もしかしたら、去年の私のように、どうしてもA&Dの作問をしなければならない状況に陥る人もいるかもしれません。
軽い気持ちでA&Dの大会を開くことはまったくもってオススメはしませんが、どうしても、という人のために、以降では実際にどうやって問題を作っていけばいいのか、ということを書いていきます。
その途中、プレイヤー側が取りうる病的なカウンタープレイとしてどのようなものがあるのか、その対策として何をしなければならないか、というのも、可能な限り触れていきたいと思います。それらを見れば、A&Dの問題を1問作るだけでどれほどまでに思慮を重ねなければならないのかがある程度分かってもらえると思いますし、A&Dの問題を無鉄砲に作ろうとするのは諦めてもらえるんじゃないかと思っています。

※これからも否定的な主張が永遠に続くのでここで注釈しておきます。私はかなりのA&D否定派なのでここまで強く反対していますが、そもそもCTFの作問は“ミスってなんぼ”だと思います。ミスしないと人は成長しないので。その観点では、私の反対意見やアドバイスを踏まえたうえで作問や開催を挑戦してみる、ということは、歓迎されるべきだとも思います。特に、A&Dではプレイヤースキルが高ければ高いほど競技が壊れやすいことを考えると、初心者向けの大会などは十分成立しうる可能性は秘めていると思いますし。カジュアルな大会は多少歓迎されるべきじゃないでしょうか。まあ私が主張しているのは、オートスケールするJeopardyと違って、ゲームバランスの調整を、天才的な感覚による手動調整でしかできないというのが問題だという点ですが...

# 1. 競技全体として、ルール・システム設計を決める

A&DのCTFは、設計で9割決まると言っていいです。ここでミスると絶対に取り返しがつきません。

### 1.a. 競技時間は短くする、もしくは問題がリタイアする制限時間・条件を設ける

これはプレイヤーのどんなずる賢い戦略に対しても有効な手であり、運営・プレイヤー双方の健康のためにも非常に良いポリシーなので、ぜひ採用してほしいと思います。

問題の賞味期限を短くすると、初見のプレイヤーがその問題に対して取れる行動の幅を一定制限できます。反対に、これが長ければ長いほど、プレイヤーはあなたの想像を超える方法で問題を攻略してきます。

競技を2日以上やると、運営もプレイヤーも非常に過酷なので、私のオススメは競技全体の時間を1日以内に収めてしまうことですが、もし2日以上やりたいのであれば、まず1日目の問題を2日目に持ち越さないことは必須だと思いますし、1日以内でも、「ある問題から合計X点以上の得点移動が発生した時点でその問題はリタイアする」といった決め事をしておくことも、不必要に長い時間、問題を生かさない上で有効だと思います（また、このルールは、ある問題が、他の問題よりも価値を持つことの対策にもなります）。

#### 失敗例 1.a.1. トランスパイルによるスーパーマンパッチ

> pwnの問題を出題したところ、あるチームに、バイナリ全体をリバースエンジニアリングによってC言語に復元したうえ、トランスパイラによってPythonに変換されたものをパッチとして提出され、まともに問題に取り組まずにメモリ脆弱性をすべて解消されてしまった。
> パストラバーサルなどの高レイヤの脆弱性も仕込んでおいたが、Pythonに書き換えられてしまったことにより、ファイルオープンに対してhookを仕込まれ、hook内にflagを開かないかを確認するチェックを挿入するだけで対処されてしまった。

この失敗例は、間違いなく過去、実際に行われたことがあるプレイングです（目撃したこともある）。
このプレイングが非常にずるくて絶対に発生を避けなければならないものか、というとそうでもないとは思います。例えばこれを実現するのに、5時間かかるとして、競技時間が7時間や9時間なのであれば、競技時間のうち相当な時間を、この作業に費やしていることになります。この場合、「すべての脆弱性が解消されるという報酬に見合っただけの時間を、コストとして支払っている」と捉えることもできるでしょう。
これが問題になるのは、競技時間や、問題が生きている時間に対して、この作業の時間が著しく短くなる時です。「48時間以上続くCTFで、たった5時間のコストを支払うだけで、すべての脆弱性を見落とすことなく完全に解消できる」と聞けば、防御の点数を安定して確保する上では非常に良い戦略になってしまっているとは思いませんか？
また、LLMの到来によって、この戦略の実行がより簡単になってきていることに注意が必要です。

#### 失敗例 1.a.2. "宿題"による崩壊

> 大会期間を2日としてオンサイトのA&D CTFを開催した。競技1日目終了時はどのチームも似たような得点状況で、接戦だったといえる。しかし、夜をまたいで2日目に入り、状況は一変した。あるチームが、どのチームも完全には解析しきれていなかった問題を夜の間に完全に攻略し、すべての脆弱性を解消した上で、すべての脆弱性に対するexploitをそれぞれ作成してきた。そのチームは、それらのexploitを1つずつ小出しにして、2日目が終了するまで、全チームに攻撃を刺しきった。ほとんどその得点移動によって勝敗が決してしまった。

2日以上開催される、オンサイトのCTFにおいてはこういった"宿題"の概念がよく見受けられます。これはA&Dに限った話ではなく、Jeopardyでもあるあるではありますね。しかし、A&Dにおける宿題は、Jeopardyのそれとはまったくと言っていいほど性質が異なります。Jeopardyにおいては、first blood pointを除けば、同じ問題が解けた場合、同じ点数を得ることが可能です。
他方、A&Dにおいてはスコアの計算式は、ラウンドを経ると共に累積的に増加していくようなものにならざるをえず、早く脆弱性を見つけて修正や悪用しているチームは、大きく得点差をつけることが可能になります。つまり、「宿題をこなしたかどうか」だけで勝敗が決する状況に陥りやすいと言えます。
また、上述した例では、あるチームだけが宿題をこなしてきた設定にしましたが、全チームが完全に問題を解ききり、すべての脆弱性を解消した場合を考えても、それはあなたが望んでいる状況ではないはずです。2日目の競技が意味をなしていません。プレイヤーも、わざわざ徹夜で書いたexploitがどのチームにも刺さらなくて、悲しい思いをします。であるならば、1日目の問題を2日目に持ち越す意義がない、ということです。

### 1.b. sshベースで大会は絶対に開かない

「sshベース」とは、各チームに、自チームのサーバーに対するsshやRDPでのアクセス権を与え、パッチやmitigationの導入などを好きにやらせる方式です。sshベースと対を成すルールとして、各チームにパッチの提出だけをさせ、運営側が管理しているサーバーにパッチを適用して動かす、いわゆるマネージドなルールがあります。現実の大会のほとんどでは、dockerを用いて、docker imageを提出させるような形で実現されるため、ここでは便宜上dockerベースと呼称します。

明確にしておくと、この章のタイトルのとおり、私はsshベースの非常に強固なアンチです。理由としては以下のとおり複数あります：

- プレイヤーができるカウンタープレイの幅が非常に増える。特に、プレイヤーにroot権限を与えた場合は目も当てられない（root権限を与えないことはすなわち、一定マネージドにやる必要が出てくることに注意する）
- インフラが故障したときに、プレイヤーが行ってきた変更が保存されない可能性がある。例えば、インフラが故障し、すべてのサーバーにリセットが必要になった時、これまでプレイヤーが施したmitigationや設定変更が正しく復元できない可能性がある
- 最も強い理由として、失敗例1.b.2.は極論として一般に防げるものではない（少なくとも、作成する問題側に強い制約がかかる）
- その他些末な理由として、「パッチ適用タイミング（プロセスの再起動）がたまたまSLAと被り、SLA failになったら責任を取れるのか？」というのがある

オンラインで不特定多数のチームが参加できる大会では、どうしてもプレイヤー側がインフラを導入する必要があるせいでsshベースになってしまいますが、本来であればできるだけ避けたほうが望ましいです。

ちなみに、HITCON CTF Finalsは初めからsshベースを採用していませんし、DEFCON CTF Finalsも2014年を境にsshベースをやめました。これらは、sshベースを利用すべきでないと考えている人が私だけではないという傍証になっていると思っています。

#### 失敗例 1.b.1. 過剰な権限によるフィルタリング

> 各チームに、自チームのサーバーのroot権限を与え、sshを許可してA&D大会を開いた。
> root権限を与えているため、プレイヤーはSLAも含めたパケットのキャプチャを取得可能であった。この状況では、プレイヤーから送信されたパケットと、SLAから送信されたパケットは、十中八九、識別することができる。
> 例えば、TCP/IPヘッダからOSを推定することができることは有名であり、SLAがLinuxから送信されているのであれば、WindowsやmacOSから送信されているパケットはSLAではなく、プレイヤーが送信していると分かるため、すべてフィルターしてしまってよい。あるいは、より直接的に、送信元IPアドレスやTTL、RTTによるネットワーク上の距離の推定などを利用して、SLA以外をすべてフィルターできることがある。他にも、セグメント長やソースポート番号といった情報すら、統計的な手法を用いて識別に利用できる可能性がある、ということに注意が必要である。
> SLAとプレイヤーの送信するパケットの特徴量に、十分な差があることに気づいたチームは、それを元にパケットをフィルターするmitigationを実装し、適用した。結果として、以降、そのチームの問題サーバーには、他チームは一切接続できなくなり、当然一切の攻撃が通用しなくなった。これによって、競技が成立しなくなった。

ちなみに、ICCにおいてはこのような防御方法も賢いプレイの一つなんだから許容すべきと言っている人がいました。ICCでは、準備の時間が最大半年程度与えられていて、競技プラットフォームの仕組みもプレイヤーに対して公開されます。プレイヤーのレベルが非常に高いこの大会で、そのようなことをするとどうなるでしょうか？間違いなく、事前準備において上述したような完璧な防御を実装してくるチームが現れ、競技開始後5分で、どの問題でも、そのチームに対して攻撃できなくなります。その後は、その戦略に気づいたチームが1チームだけならば、そのチームの優勝でしょう。気づいたチームが複数いれば、その戦略に気づかなかった他のチームを如何に食い物にできるかで決着がつく、という大会になります。それは競技として本当に成立しているでしょうか？それは本当に見たいものでしょうか？

#### 失敗例 1.b.2. 統計的手法によるフィルタリング

> sshベースで大会を開いた。失敗例1.b.1.を防ぐために、問題サーバーは運営側で用意し、root権限は与えないことにした。これだとプレイヤーがパケットをキャプチャする手段がないため、運営側でパケットをキャプチャし、各パケットを十分に匿名化した上で提供した。
> すると、あるチームがそもそもパケットに頼らず、サービス側でクライアントのペイロードをすべて保存し、それを元にプレイヤーの送ったペイロードとSLAの送ったペイロードを識別するという手法を思い付き、なんとそれを十分な精度で実現してしまった。
> プレイヤーがペイロードを送信してくる際、タイミングや内容には非常に偏りがあり、他方、SLAは十分ランダムに近い内容をランダムなタイミングで送信してしまっていたため、教師なし学習や、半教師あり学習に近い手法を用いて十分に識別可能であった。

私は長年、sshベースでは、この失敗例が極論、防げないという主張をしています。sshベースでは、パッチを適用できる回数に制限がないうえ、問題サーバーが、ラウンドを跨いで情報を保存できるという一種のpersistenceがあります。プレイヤーが送信するペイロードと、SLAが送信するペイロードの分布はどう頑張っても異なります。そして、複数ラウンドを跨いで、情報が蓄積すれば蓄積するほど、これらの識別をやる方法は増えます。

パケットを提供した時点で、dockerベースでも同じことはできるだろうということを思った人もいるかもしれません。それはその通りですが、dockerベースでは、persistentではない（リセットされる）ため、新しく学習を行って重みを変更した識別器をデプロイするためには、毎回パッチの提出が必要です。パッチの提出には基本的にペナルティが伴うようにするので、sshベースよりは同様の戦略を咎めることができます。sshベースでは、そもそもパッチの提出にペナルティがあるという概念はないのでデプロイし放題ですし、そもそも、オンライン学習的に重みの調整を自前で行っていけます。また、後述しますが、dockerベースでは、「パケットの提供を遅延する」、「パケットをSLAに含めない」、といったオプションも存在するため、更にSLAを識別するためのコストを増大させることができます。

前述のように、この問題はdockerベースでも生じうることに注意が必要です。SLAの生成分布を毎ラウンド変更するなどの対策を取ればマシにはなりますが、今度は反対に、「プレイヤーが送信してくるパケットの分布を推定する」といった手法ができる可能性があります。

#### 失敗例 1.b.3. Local Privilege Escalation

> ルール上禁止にしていたものの、0day exploitを使ったチームがおり、root権限を奪取され、失敗例 1.b.1.を引き起こされた。

dockerベースでも同じルール違反を引き起こされる可能性はありますが、dockerベースでは、外部サーバーやWANへの接続をネットワーク側で制限しておくことで、persistenceはできなくできるため、被害を一定緩和できます。つまり、sshベースとは異なり、「されたら終わり」ではありません。

まあこの失敗例については、ルールで禁止しているためそこまで問題になることは稀でしょうが、仮にルール違反が起こった場合には、運営がルール違反を見抜く必要があるということに注意してください。ルールを厳しくすると、運営の負担も増えます。

#### 失敗例 1.b.4. システム障害によるパッチの喪失

> インフラのバグにより、プレイヤーが問題サーバーに接続できなくなり、解消するためにはバグを修正した上で、問題サーバーをすべてリセットする必要が出た。急遽リセットしたところ、あるチームから、「サーバーに行った変更を手元で記録していなかったから完全に復元することが難しいし、そもそも一部のパッチは手動で行ったから適用には時間がかかる。この間に攻撃されたら困る」というクレームがついた。

これをできるだけ避けようと思うと、リセット前にバックアップを取るように促すといったことはできるかもしれませんが、そもそも問題サーバーに接続できなくなった場合には不可能です。運営側でバックアップを取って提供することも一応考えられるかもしれませんが、もしプレイヤーがオンメモリに何かを保存していたり、再起動でリセットされるような何らかのコンフィグを変更している場合には、それすらうまくいかないかもしれません。もちろん、プレイヤー側もどういったパッチを行ったかは記録しておいた方が良いわけなので、半分はプレイヤーのミスではあるのですが、プレイヤーから「システムに問題がなければ、我々のパッチは正常に動き続けていた。リセットされたことによって我々のサーバーが攻撃されるようになった場合は運営に責任があり、何らかの補償があるべきだ」という主張をされた場合、それは一定正論です。

### 1.c. パッチには制限を設ける

パッチの回数やサイズに制限を設けないと、プレイヤーの異常なカウンタープレイを誘発しやすくなります。極端な例を出すならば、あるチームが、数年かけて作成した数百万行からなる謎の最強防御システムをパッチとして導入してきたらどうなるでしょうか。A&Dは、競技の性質上、事前準備が勝敗に多少寄与することは許容すべきであり、それが醍醐味である側面もありますが、この例は流石に想定を超えていると思います。特に、LLMとvibe codingの到来によって、大規模な変更を短時間で実現することが比較的容易になってきていることも加味すると、極端な例ほどではなくとも、かなり強い防御策を短時間で準備できる可能性は大いにあると考えるべきでしょう。

回数についての制限は、提出のたびに減点を行うのが一番簡単です。明らかに異常な回数のパッチの提出は禁止しつつ、パッチを頻繁に行いたいチームは、ペナルティを受け入れればそれを行ってもよい、というのは非常に公平だと思います。
他の制限の掛け方として、レートリミットを設けて、一定時間内に提出できるパッチの回数を制限するものもあります。近年のDEFCON CTF Finalsはそうしていましたね。私としては反対ですが（純粋にパッチで何らかのミスをした場合に、プレイヤーとしては即時修正したいわけで、レートリミットの解除を待って時間をロスするのは非常にストレスです）。

サイズについての制限は、色々な方法があると思いますが、基本的にはdocker imageのレイヤーサイズや、提出させたファイルサイズの総計を適当に集計し、許容される上限値を問題ごとにハイパーパラメータとして設定することになるかと思います。
特に、問題のファイルサイズが非常に小さく、パッチもシンプルで済む問題においては、後述するように、QEMUなどの、あからさまに異常なファイルサイズのファイルを必要とするパッチは弾いておいた方がよいです。

その他の制限として、変更不能なファイルやディレクトリ構成を設定しておくことも時として非常に重要です。特に、複数のユーザー権限を利用する問題において、プレイヤー（が処理を決められるコンポーネント）に持ってほしくない権限を持てなくするためには必須になるはずです。失敗例 1.c.2.は、これをしなかった場合の失敗として最も分かりやすい例と言えるでしょう。

おそらく上述したような考察と同様のことを考えた結果として、HITCON CTF Finalsでは毎年非常に強力な制約を設けていたように思います。
具体的には、許可されているのがバイナリへのパッチのみで数十バイトまでしか変更できなかったり、提出したパッチをすべて運営が目視で検査していて不正がないかを確認していたり、バイナリに対してはパッチできず、前段におかれているプロキシにおいてWAFのようなイメージで通信のフィルターだけができるようになっていたり、といった感じです。

ちなみに、この章で説明している内容は、sshベースを推奨しない理由の補強にもなっています。sshベースで大会を開いた時点で、ここに書かれているようなパッチに対する制限がほとんど掛けられなくなるためです。

#### 失敗例 1.c.1. QEMUによるスーパーマンパッチ

> pwnの問題を出題したところ、QEMU上で動かすようにwrapされ、すべてのシステムコールの監視を実現された。フラグを開くopenシステムコールだけ失敗するようになり、攻撃ができなくなった。

ちなみに、このような「問題の性質をほとんど無視し、ユニバーサルに適用でき、攻撃を完全に無効化するような防御策」のことを、スーパーマンパッチまたはスーパーマンディフェンスと呼びます。
これに対する対策は個々の問題側でもできなくはないですが、次の例に示すように、実装力さえあれば迂回することもそれなりに可能です。
よって、システム側で対策する方が安全かつ簡単であり、具体的には、QEMUは単純にバイナリのサイズが非常に大きくなるわけなので、パッチの上限サイズを定めておけば対策としては十分です（上限サイズというハイパーパラメータを良い感じに定めるのは面倒ですけどね）。

ちなみに、私のチームは10年ほど前にこれを実際のsshベースの大会でやったことがあります。結果としては最強で、運営に「今すぐにやめろ。失格にするぞ」と言われましたが、そもそもこれは当時ルールで禁止されている行為ではなかったので非常に不満でした。A&Dのルールを作る時は、「その他、競技全体を実施できなくしたり、競技性を著しく損ねると考えられる行為は、運営の判断により禁止することがある」というブランケットなルールは記載しておいた方がいいです。

#### 失敗例 1.c.1'. QEMUによるスーパーマンパッチの対策の迂回

> 失敗例 1.c.1.の対策として、正規の機能としてフラグを利用する処理を用意したが、スタックトレースを見て、正規の機能だと判断した場合にのみ許可する判定処理も実装されてしまったので、どうしようもなくなった。

問題側で対策しようとすると、どう頑張ってもプレイヤー側が強いです。頑張れば頑張るほど問題設計や脆弱性に制約がつきます。

#### 失敗例 1.c.1''. QEMUによるスーパーマンパッチの対策の迂回の対策の迂回

> 失敗例 1.c.1'.の対策として、正規の機能として、フラグを読み出し、オンメモリにおいておかなければならない状況を作ったが、テイント解析的にフラグの内容が漏洩しうるときだけ出力を禁止する処理を実装されてしまったのでどうしようもなくなった。

いたちごっこです。

#### 失敗例 1.c.2. クローンとプロキシによる防御

> あるチームが、特殊なパッチを導入してきた。そのパッチでは、プロキシを設置したうえで、問題インスタンスを安全なサンドボックスの中で複製し、クライアントから来た入力を、複製したインスタンスに先に投げつける。ここでレスポンスに異常があった場合には、exploitであると判断して、通信をシャットダウンしてしまう。レスポンスの異常とは、例えば具体的には、レスポンスが返ってこなかったり、ダミーフラグが漏洩していたり、正規のサービスとレスポンスが異なったりすることを指す。
> 特に、pwnの問題において、メモリアドレスが重要な問題では、これが導入されたことによって、exploitが不可能になってしまった（クローンされたプロセスではメモリアドレスが異なってSEGVするため、それをオラクルとできる）。

これは、問題側が頑張れば、対策する必要がないケースもありますが、問題側で対処する場合は確実に作成する問題になんらかの制約がつき、結構大変になります。
システム側で、「パッチできるファイルはこれとこれだけ、起動中に他のファイルを置くことはできない」といった制約を掛ければ、これを心配する必要はなくなります。

#### 失敗例 1.c.3. ラウンドごとなどに変化するパッチ

> パッチの回数を制限していなかったため、あるチームが10秒ごとに異なるパッチを提出し、毎回挙動が変化するようになってしまった。
> その大会ではルール上、適用されたパッチは常に公開されていたものの、10秒ごとに全く違うパッチになってしまうため、他チームからすると、解析が事実上不可能になり、攻撃ができなくなってしまった。

具体例として、バイナリのアドレスやサブルーチンの配置が毎回に変化するようなパッチを投げられると、高レイヤな脆弱性以外は実質的に無効化できます。

#### 失敗例 1.c.4. hardened malloc

> pwnの問題においてheapの脆弱性をたくさん仕込んでおいたが、hardened mallocをLD_PRELOADするパッチを導入され、開始3分ですべてexploit不可能にされてしまった。

これは2章や3章でも考慮すべき（問題の設計においてもどうにかすべき）問題ですが、例えばシステムとして、単一バイナリのパッチだけを許可し、LD_PRELOADなどを利用不能にしておくと、少なくともノーコストでheapの脆弱性をすべて潰すといったことはできなくなります。

### 1.d. パッチは公開する（ほうがよい）

ブラックボックスな防御はなんやかんやで強くて理不尽というのがあります。特に、A&Dでは、攻撃と防御のいたちごっこをすることに競技的な楽しさがある側面もあるわけですから、パッチはオープンにしている方が良いでしょう。

とはいえこの項目については好みの範疇です。一応非公開にしても競技は成立させられます。ただし、下記のような失敗例が発生しやすくなり、ゲームバランスを正常に保つことが難しくなるということは認識しなければなりません。実際、ICCにおいては、伝統的にパッチ非公開のルールであったこともあり、パッチ非公開での作問を強いられましたが、これの対応にはかなり苦労しました。

#### 失敗例 1.d.1. リロケーションによるスーパーマンパッチ

> パッチを公開しないA&Dの大会を開いた。pwnの問題において、あるチームがバイナリのアドレスをランダムに変更するパッチを提出してきた。作問者の想定としては、exploitにROPが必要であったため、アドレスが変更されることによって問題が破綻した。

パッチが非公開の場合、リロケーションがかなり強い防御手段になってしまうため、pwnの問題は非常に成立しづらくなるということを理解すべきです。

まあ、実はパッチを公開したところで、ゲームバランスを保つのは難しいんですけどね。なぜなら各チームが思い思いのパッチを導入してきたとき、それらの解析は非常に人員リソースを食う作業なわけですが、あるチームのパッチを解析して回避ができたところで、得られるのはたかが1チーム分の点数です。すなわち、パッチの解析は非常にコスパが悪い作業であるため、パッチを公開したところで、みんながすべてのパッチを解析するかというとそうでもない、というのはあります。

#### 失敗例 1.d.2. 謎のヒューリスティックなフィルター

> あるチームが、SLAの実装が甘かったこともあり、SLAが通過する範囲で、謎のヒューリスティックなフィルターを導入してきた。
> そのフィルターは、実際の中身としては、「リクエストの中身が50バイトを超えると弾く」、「記号が3種類以上含まれると弾く」、「リクエスト長に対して、利用されている文字種が一定の比率を超えない場合には弾く」といったヒューリスティックなルールを複合させて実装されているもので、実際にはバイパス可能であったが、ブラックボックスなことと、あまりにもルールが多いことが相まって、どのチームも攻略できなかった。

まあこれは、SLAが甘かったことを除けば、許容されるゲームプレイではありますし、現実にはパッチが非公開でない限りどのチームもやらないような気はしますが、バイパス可能ならバイパスさせてあげたほうが競技性はあるんじゃないでしょうか。

### 1.e. SLAの方針を決める

SLAは、A&Dにおいて、チームのパッチが不正をしていないことを証明する唯一の手段であり、非常に重要です。
一般にはラウンド中、ランダムなタイミングで、正常系リクエストを送信し、期待するレスポンスが返ってこない場合には不正が行われているものとして、SLA failと判断します（減点します）。

実は他の方式として、「パッチ提出時に、SLAのテストを行い、通過したもののみ本番サーバーにデプロイする」というものが考えられます。すなわち、CI/CDと似たようなイメージで、デプロイ前にSLAテストが走り、ラウンド中、ランタイムにおいては、SLAが本番サーバーにリクエストを送信することはしない、というものです。これは実際に近年のDEFCON CTF Finalsで利用されている方式です。

どちらの方式も、メリット・デメリットがあるのですが、特にDEFCONの方式において致命的になりうる問題が「問題インスタンスが、『自分が今SLAテスト中なのかデプロイされた後なのか』を判別する方法があると、『SLAテスト中だけ正常に動き、ランタイムでは動作を停止する』というスーパーマンパッチが可能」というものです。
この不正を引き起こさない、ジェネリックな対策方法があるか、というのは私が知る限りでは未解決で、吟味されていない問題だと思っています。そのため、open problemとして記載しておきます。もし、どう考えても不正がしづらい方法があるのであれば、DEFCONの方式の方が利点が多いため、推奨されるようになるでしょう。
未解決であるため、まあ現状ではどちらも取ってもよさそうだということで、ここでは「どちらか決めてください」という書き方にしています。

### 1.f. パケットを公開するまでの遅延時間を決める

一般に、exploitの作成は、patchの作成よりも時間がかかることが多いです。前者は下手すると数時間かかるのに対し、後者は数分程度で済むこともよくあります。
A&Dでは、どのような攻撃が行われているかのヒントを与えるためにパケットを公開するのが一般的で（かつ推奨されま）すが、遅延を設けずにパケットを公開してしまうと、パケットから脆弱性を探し、patchを作成する方が、exploitの作成よりも早くできてしまい、攻撃で得られる点数が少なくなりすぎる可能性があります。
本来、一番初めに脆弱性を見つけ、一番初めにexploitを書いたチームというのは一番偉いわけで、十分に見返りをもらうべきです。しかし、パケット公開が早すぎると、パケット解析によって脆弱性を見つける、二番手以降の便乗者との差がほとんどなくなりえます。

#### 失敗例 1.f.1. リプレイツールによる防御優位

> 遅延なしでパケットを公開していたため、どのチームもパケット内のペイロードをすべて抽出し、手元の問題インスタンスに流して挙動を見るリプレイツールを実行していた。
> 特に、pwnの問題では、メモリアドレスが違うせいで、リプレイツールによって容易にSEGVが発現し、すぐに脆弱性を修正できてしまった。結果として、exploitによる点数差がほとんど生じず、web問題の比重が強くなり過ぎた。

### 1.g. DoSを許容するかどうかを決める

SLA scriptが問題インスタンスに接続できなかった場合、scriptは当然評定をSLA failにせざるをえません。パッチが不正に通信をシャットダウンして、攻撃不可能にしてる可能性があるからです。
しかし、これはすなわち、問題インスタンスにおいてDoSが発生した場合、SLAがfailすることを意味します。よって、他チームによって、DoSが引き起こされ、SLAがfailして減点される恐れがあります。

当然、大量の通信によるDoSは、競技性に照らして考えてもしょうもないですし、検出も容易ですから、ルール上禁止にしてしかるべきです。では、ロジカルDoSはどうでしょうか。
ロジカルDoS、すなわち、サービス側の脆弱性や実装不備に起因して、例えば単一のリクエストを送信するだけで、サービスが接続不可になることというのは普通にありえます。
ロジカルDoSは、思考停止で大量に通信を発生させるのとは異なり、メモリ破壊やファイル漏洩を引き起こす脆弱性のように、“面白い”部類の脆弱性であることの方が多いですし、場合によっては発見が難しいこともあります。
ルール上これの悪用をプレイヤーに認めるかどうかというのは、ある種の自由度のある選択肢ではあって、どちらに倒してもメリットとデメリットがあります。
プレイヤーがロジカルDoSを引き起こすことを認めた場合、DoSを引き起こす脆弱性も、ゲームプレイとして有効になるという面白さがあります。
他方、SLA failした場合に、それがパッチに起因するのか、他チームによるDoS攻撃なのか見分けがつきづらくなるという問題があります。よって、DoSを許容する場合には、例えば、他チームが接続できない、本番サーバーのクローン環境を用意し、「そちらでもSLAが落ちているか否か」という情報を各チームに提供する、といった特別な対処をする方が望ましいです。

ロジカルDoSを認めない場合には、後述するように問題設計において、DoSが発生しづらい設計を考える必要があり、これは非常に大変です。また、当然競技中は、通信やSLAの状況を監視して、DoSによるSLA failが発生していないか、発生している場合には、特定のチームが原因になっていないかを常に見守る必要が生じます。
ICCでは、DoSによる意図的な他チームのSLA failの誘発は禁止されていたため、本番中の監視業務も非常に苦しかったです。

### 1.h. 1問が複数のフラグを持つか決める

これも自由度があり、好みの範疇ではありますが、一部のA&D CTFにおいては、flagstoreと呼ばれる概念があり、1つの問題の中で複数のflagstore（フラグが配置される場所）を持つことが可能です。
これによって、例えば、webの問題においては、データベースの中に1つのflag、巡回するbotブラウザのcookieに1つのflag、のような形で、悪用する脆弱性や、侵害するコンポーネントごとに、flagを持たせるようなことが可能になります。

これは、システム側が実装を頑張れるのであれば、単一のflagstoreのみに制限しても、複数のflagstoreを持っても、好みの範疇と言える話ではあります。しかし、個人的には、複数のflagstoreを持つのは、大変になるのでやめておいたほうがいい派です。
私は思想として、全ての問題のスコアの重みは、均等である（ような機会を少なくとも持つべき）という考え方を持っています。
不均一に、複数のflagstoreを各問題が持ちえる、という状況は、この原則にどう頑張っても反します。
例えば、ある問題が1つのflagstore、もう一つの問題が3つのflagstoreを持っているとします。
後者の問題において、単一のラウンドで3つのflagを盗んだチームは、前者の3倍スコアを得るべきでしょうか？
これを肯定する場合、後者の問題は、前者の問題よりも、最大で3倍の価値を持つことになります。
では、反対に、n個のflagstoreを持つ問題において、1つのフラグを盗んでも点数を1/n倍にするとどうでしょうか？
今度は、前者の問題が、後者の問題よりも、最大で3倍の価値を持つことになります。
このことは、天才的な作問者が、完璧なゲームバランスを提供できるならば問題にはならないかもしれません。しかし、現実にはそのようなことは起きるはずがなく（どちらの問題がどの程度解かれるかが、参加チームの傾向によって、常に変化すると考えられ）、どのように比重を定めても、それが定数倍である限りは、恣意性があるでしょう。

ICCにおいては、伝統的に複数のflagstoreを持つことが義務付けられており、非常に困りました。
最終的に、我々は、1ラウンドで、ある問題に対してあるチームが得る点数を、（そのチームが盗んだフラグ数）/（全てのチームが盗んだフラグ数の合計）で定義することによって、上記のような問題を一定緩和しましたが、そもそもflagstoreを複数用意すること自体が厄介の種であると思っています。

### 1.l. プラクティスセッションを設ける、APIドキュメントの拡充など

これも好みの範疇の話になりますが、上述・後述する推奨事項をすべて守ろうとすると、どうしても独自のA&Dシステムを開発して利用する他なくなります。
このシステムに対して、プラクティスセッションやドキュメントを準備しなかった場合、プレイヤーにとっては、競技本番がシステムに触れるはじめての機会になります。

「以下に初見のシステムに早く適用し、flag提出などの自動化を素早く整備できるか」というのは、競技のスキルとして問うてもまっとうと言えばまっとうですし、面白いものではありますが、プレイヤー目線では、すべてを隠されたまま、ぶっつけ本番で、もしかしたらバグがあるかもしれない競技システムに触れさせられるのは、非常にストレスです。
よって、可能であれば、プラクティスセッションや、APIドキュメントの提供は、競技開始前、できれば、数週間・数か月前に行った方が、より親切でストレスのない競技運営になると考えられます。

ただし、これまで述べたとおり、事前に競技システムの情報を与えれば与えるほど、プレイヤーによる病的なカウンタープレイが行われる可能性が高まることには注意すべきです。正直にいえば、「1.a. 競技時間は短くする」で述べたとおり、この懸念に対するベストな対策は、システムの情報を競技開始まで一切非開示にし、対策するための時間をできるだけ与えないことなのですが、情報を与えなければ与えないほど、プレイヤーに不便を強いて、競技本番におけるプレイヤーのパフォーマンスを下げることになってしまうため、このバランスは非常に重要です。

# 2. 問題のコンセプト・設計を決める

前述した通り、A&DのCTFは、設計で9割決まります。ここでいう設計は、大会全体のルールだけを意図しているのではなく、個々の問題の設計も含んでいます。不正が理論上防げるかどうかを決めるのが、全体のルールや設計で、不正が実際に防げるかや、防ぐコストが十分に低いかを決めるのが、問題の設計、というイメージになります。問題の設計をミスると、ほぼ間違いなく問題不備をどこかで引き起こしますし、最悪の場合、問題として完全に破綻する可能性があります。

実際、ICCでは5問出題したうち、運営側の不備が一つも見つからなかった問題は1問だけでした。この1問は実は私の問題なのですが、私の注意深さが優れていた、というわけではなく、なるべくミスが起こりづらく、悪さができないように初めに設計したのが功を奏しています。私が他の作問者のテーマで作成していたら、おそらく私もミスをしていますし、反対に私のテーマ・設計を使えばほとんどの作問者はミスしていないでしょう。それほど、問題のテーマや設計というのは重要です。分かりやすい指標として、作ろうとしている問題に、「サービスがroot権限で何かをする」、「正規の機能として、ユーザーに任意のコード実行させることができる」といった特徴がある場合は黄色信号です。特に後者を許可する時点で、プレイヤーが、作問者が想像していなかった不正やミスをする可能性は跳ね上がります。

他方、設計を厳しくすることは、埋め込める脆弱性の多様性やプレイヤーの戦略の幅を狭めることに近しいわけなので、問題としての面白さを減らしうることには注意が必要です。このバランスを取るのは非常に難しく、時として、作問ミスする可能性を増大させてでも、複雑なコンセプトの問題を作るべき時もあります。ICCでは、そういったバランスを考えた結果、独自OS上でユーザーのプログラムを動かす問題や、競技プログラミングのジャッジシステムなどのテーマを取り扱っています。

具体的には、以下の項目について考える必要があるでしょう。本当は、以下に記載されていることは順番に考えるのではなくて、同時に考えるイメージの方が正確ですが、強いて言うならで順序付けは行っています。また、3章および4章の内容も、問題のコンセプトと設計を考える時点で考慮しなければなりません。以降はすべて、同時に考えなければならないもの、ぐらいに思っておいてください。

### 2.a. （許容しない場合）DoSで落とせないようにする 

1章で記述したように、ルール上、他チームによる意図的なロジカルDoSでの妨害を許容するかは自由度があります。
これを許容しなかった場合は、ルールにおいて「ロジカルDoSは許容しないし引き起こした場合にはペナルティを与える」と明記するのはもちろんこと、極力そのような事態が発生しないよう、作問においてロジカルDoSが起きうるパスを可能な限り潰す必要があります（この対策をせず、100件そのようなDoSが起きた時、あなたは適切にペナルティを与えられますか？ペナルティを与えられないルールに実効性はありません）。

DoSで落とせないようにする、というのは言うは易く行うは難しです。まず、問題を十分複雑に設計して、かつ、自分を信用しないのであれば、意図せぬ実装不備や、exploitの何らかの干渉によって、プロセスが無限ループしたり、ゾンビ化することは容易に想定されるので、子プロセスをタイムアウトしてキルするような機構は具備されるべきでしょう。
また、ロジカルDoSは、確かに注意していればあまり産まない脆弱性であることは認めるものの、RCE可能な脆弱性も、ロジカルDoSに近い性質を持ち、注意されるべき脆弱性であることに注意が必要です。
シェルを取ったチームが、他のプロセスすべてに対して、killを発行したらどうなるでしょうか？その状態でも、SLAがfailしないことを保証できますか？
DoSで落とせないようにする、というのは、そういうことです。

ICCにおいては、どの問題においても、この懸念に対して苦心して対策をしました。例えば私の問題では、まず権限を分離することで、サーバープロセスに対するkillは無効にした上、sandbox化によってprocfsを露出させないようにしたり、SLA script側でも、予期せぬ接続切れの場合は再リトライするようにしたり、といった工夫があります。

### 2.b. SLAで確認する内容を考える・網羅性をできるだけ担保する

前述したように、SLAはパッチによる不正がないことを担保するための唯一の手段です。
4章でも後述しますが、SLAが満たすべき性質は以下のとおりです：

- ユーザーが送信するパケット・ペイロードとできるだけ区別がつかないようにする
    - 例えば、SLAが送信しない入力値があるならば、パッチはその値を受信した瞬間に、当該接続はSLAではないとして通信を切断してよくなります。理論上、正常な入力はすべて、生成されるようにすべきです
- すべての実装・機能ができる限りテストされるようにする
    - SLAがテストしない機能があるならば、極論パッチはその部分はnopで埋めてよくなります
- ありとあらゆる不正・面白くないカウンタープレイに対する対策を行う
    - プレイヤーが思いつきそうな小手先のごまかしはすべて潰しましょう。例えば、webの問題で、何も考えずにとりあえずWAFを適用するチームもあるかもしれません。これが面白くないと考えるならば、WAFを誤動作させるような入力を、SLAで入力してもいいです

この時点で、SLAで確認できない不正がないかというのは確認しなければなりません。

### 2.c. パッチの適用できる範囲・パッチに許す操作を考える

これについても前述したとおり、パッチできる範囲を適切に制限しなかった場合、プレイヤーに意図せぬ強い権限を与えてしまったり、想定外のカウンタープレイを許してしまう可能性があります。例えば、失敗例 1.c.2.を防ぐうえでは、許可した場所に許可したファイルのみを配置できるパッチのみを許可すべきでしょう。

また、適切に設計すれば、パッチが任意に悪意のある処理を実装したところで、より上流の、プレイヤーが操作できないコンポーネントにおいて、吸収できる場合があります。そのような例を 2.c.2.に記載しています。

#### 失敗例 2.c.1. 過剰な権限の付与

> dockerベースのA&Dの大会で、CGIが実行されるWebサーバーの問題を出題した。
> CGIでRCEされても、SLAや他のプロセスを意図的にkillできないように、CGIが実行されるユーザー権限はWebサーバーのユーザー権限と分離した。
> また、CGIは、webの問題だけでなく、pwnの問題としても簡単に利用できるように、バイナリパッチを禁止する目的で、CGI自体のパッチは禁止した。その代わり、パッチでは、Apache ModSecurity CRS (Core Rule Set) により、WAFのルールのみを編集可能なようにした。
> 以上によって、そもそもプレイヤーはパッチとして、任意のコードが実行できない状況になっているはずである。したがって、失敗例 1.c.2.のような不正は、そもそも任意のファイルが置ける状況にないので、実行不能になったはずだ。
> ここまで設計は完璧なように思われたが、実はCRSはデフォルトでLuaによるコード実行が可能だった。
> プレイヤーは、CRSのルールを経由して、Webサーバーの権限で任意のコード実行が可能であり、結果として、失敗例 1.c.2.やバイナリパッチなど、想定していないパッチを適用することが可能になってしまっていた。

これはICCで私が作問した問題のifの姿です。実際には、Luaで任意のコード実行が起きる懸念もはじめから把握していて、真っ先に潰しています（luaモジュールを除外してApache httpdをカスタムビルド）。
パッチ側で任意のコードが実行できなくする、という対策は、一番強力な対策ですが、本当に強制できているかは、ちゃんと吟味する必要があります。また、何度も記載しているとおり、これはプレイヤーの行動を制限していることを意味するため、自由度を下げて競技性が減少する可能性がある、というトレードオフがあることも理解すべきです。

#### 失敗例 2.c.2. cookieの付与による匿名化の解除

> dockerベースのA&D大会において、webの問題を出題した。当該問題では、パッチにおいて、コードの大半を編集可能にした。
> すると、あるチームは、独自のcookieをセットするコードをパッチとして提出してきた。
> 実はこれにより、失敗例 1.b.1.や失敗例 1.b.2.に近しい方法で、プレイヤーとSLAの識別が可能になる。
> 具体的には、仮にSLA scriptが、ヘッドレスブラウザを用いておらず、Pythonのhttpxのようなライブラリで実装されていた場合、通常、cookieを永続的に保存しない。よって、独自のcookieをセットしている通信は、プレイヤーによるものと思われるため、すべて弾いて良くなる。
> 他方、SLA scriptが、ヘッドレスブラウザを用いていることなどに起因して、cookieを保存する場合、cookieを保存していない通信は、プレイヤーのexploitの可能性が高く、弾いてよい。あるいは、User Agentの値などを見て、SLA scriptが利用しないと思われる値の場合は弾いてよくなってしまう。
> 更には、これらのフィルターを回避した通信（すなわち、ちゃんと独自のcookieを保存し、かつSLA scriptと同じUser Agentを使っている通信）すべてについて、独自のcookieを付与したことで、個々のクライアントの識別ができるようになっている。
> 結果として、失敗例 1.b.2.のような手法が取りやすくなる。

この失敗例の対策はどのようにすればいいでしょうか。
実は、ICCでは回答として、HAProxyによるプロキシを挟むことでこの懸念を解決しました。
すなわち、プレイヤー側がパッチできず、操作できない上流のコンテナを用意し、その中でHAProxyによるプロキシを立ち上げます。
HAProxyには、Luaによるスクリプティングで、レスポンスヘッダを編集する機能があるため、その中で不要なCookieやその他のカスタムヘッダについては削除するようにすると、上記のような懸念はある程度解消されるわけです。
このように、プレイヤーが操作することのできない聖域を作り、その中で一定正常な動作を担保する、という考え方は、病的なカウンタープレイに対して非常に有効です。

# 3. 脆弱性を埋め込む

さて、コンセプトが決まったら、まずは脆弱性を埋め込んで、プレイ可能な問題を作成します。脆弱性は、様々なバリエーションで、様々な難易度で埋め込む必要があります。理想的には、開始数分から数時間程度で発見され悪用される脆弱性、数時間以降に深く問題を観察することで発見される脆弱性というイメージで、時間経過とともに、脆弱性が徐々に発見されていくようにしてください。
これを満たさなければならない以上、Jeopardyの中級者向けまでの問題であれば息を吐くように作れる、というレベルの作問者じゃないと多分作るのは難しい気はします。

### 3.a. 脆弱性は修正できるようにする

まず、埋め込む脆弱性はすべて修正できるようにしましょう。
設計上破綻していて、修正できないような脆弱性は埋め込むべきではありません。

これは当たり前のように思うかもしれませんが、これが達成できない問題を時折見かけることがありますし、実は、破綻していてもそれはそれでバランスとしては成立しえます。
要は、経過時間を無限大に飛ばしたとき、飽和状態として、「全ての脆弱性を修正した状態」を最終的な状態とするのか、「全てのチームがお互いに攻撃できている状態」を最終的な状態とするのかの違いです。

しかしながら、私は、後者でバランスを取ることを絶対におすすめしません。理由は簡単で、それを達成可能にする脆弱性（すなわち、修正不能な脆弱性）に気づいた瞬間、その問題（の他の脆弱性すべて）は無意味になるからです。

### 3.b. 脆弱性はなるべく単体で攻撃可能にする

次に、特にpwnでは難しい注文にはなりますが、極力脆弱性は単体でexploit可能なように設計しましょう。
アドレスリーク用の脆弱性とメモリ破壊用の脆弱性が1つずついる、という状況は好ましくありません。
これも理由は単純で、片方でも脆弱性が修正されると、攻撃が不能になってしまうからです。
そして、次節にも関連しますが、「片方でもいいので脆弱性に気づいて修正すればいい」という防御側と、「両方の脆弱性に気づいて素早くexploitを書かなければいけない」という攻撃側ではアンバランスになります。
もし、どうしても複数の脆弱性を利用せざるをえない状況であって、バランスをうまく保つためには、同種の脆弱性を必ず複数いれるようにします。すなわち、アドレスリークをする脆弱性が必要であれば、interchangeableに利用できる脆弱性を2個以上入れるべきです。同様にメモリ破壊用の脆弱性も2個以上含め、それぞれの種別ごとに、1つだけ修正されても成立させられるようにすることが重要です。

### 3.c. 修正コストとexploit作成コストのバランスを考える

これまでにも述べてきたとおり、基本的に、CTFにおいて、修正に時間がかかる脆弱性というのはなかなかありませんし、そもそも避けるべきことの方が多いです。修正が難しい脆弱性とはすなわち、例えば設計として破綻しているなど、「修正方法が自明でない脆弱性」であり、プレイヤー目線で、「どのように修正すればSLAが通るのか」が自明でないことが多いためです。

他方、exploitは、脆弱性に気づいてからも、どのように悪用するかを吟味しなければならないことも多く、実装には時間がかかります。脆弱性の修正は数分で済むのに、exploitの作成には数時間かかるということも珍しくありません。
よって、そのような脆弱性ばかりを埋め込み、脆弱性の発見や修正をあまりにも簡単にしていると、最初のexploitが作成される前にすべてのチームのすべての脆弱性が修正され、問題として不成立になる恐れがあります。

特に、hardened mallocのように、脆弱性を発見せずとも適当にmitigationを適用すれば悪用が不可能になるような脆弱性は、絶対に埋め込むべきではありません。pwnにおいては、heap系の脆弱性は特に注意すべきです。

#### 失敗例 3.c.1. ロバストでないheapの脆弱性

> pwnの問題でheap系の脆弱性を埋め込んだ。hardened mallocに対しては、問題バイナリをstaticにし、パッチ可能なファイルをバイナリ本体に制限することで対策した。
> しかし、あるチームは`free`をnopに変換するパッチを当ててきて、UAFやdouble freeがすべて無効化されてしまった。
> 他のあるチームは、`malloc(X)`を`malloc(X+rand()%10)`に変えるパッチを当ててきて、これも実質的にexploitを書くことを不可能にした。

### 3.d. flagをステルスに盗む手段をなるべく提供する

問題に深みを与える上でできれば考慮してほしい項目として、パケットにflagの平文の痕跡を残さないexploitを作成する方法を、1種類は与えてあげたいところです。失敗例 1.f.1.でも述べたとおり、パケット解析は非常に強力なツールです。特に、flagがパケット中に含まれるという情報は、その問題にまだ脆弱性が残存していることを明らかにし、ほとんど場合は、root causeを特定するためのPoC入力まで与えています。

これまでも述べたとおり、exploitの作成には多大な時間がかかることを考えると、パケット解析が有効に働きすぎると、防御側が過剰に優位になってしまいます。そのため、パケットキャプチャ上で、flagを平文で検索しても引っかからないような、exploitの方法を1つは与えておいた方が、exploit作成者に報酬を与えることができます。
具体的には例えば、RCEが可能な脆弱性を1つでも与えておくと、プレイヤーは任意のコード実行により暗号化した状態でflagを抜き出せばよいため、成立します。

### 3.e. リプレイ対策をする

同様に、問題に深みを与える上でできれば考慮してほしい項目として、exploitのパケットをリプレイしたら、そのままflagが出てきてしまったり、SEGVが発生してしまうような脆弱性ばかりにはすべきではありません。

3.d.もそうですが、コバンザメ的な戦略が最も強くなり、真面目に脆弱性の探索とexploit作成に取り組む人間をdiscourageするような問題の設計や脆弱性は、全体のバランスを悪くするだけです。

# 4. SLAを書く

最後に、SLAを書きます。ただし、順序としては最後なだけで、これまでにも述べたように、SLAは、問題設計時点でどのようなイメージで実装するかを考えておかないと十中八九破綻することに注意してください。

### 4.a. SLAでは脆弱性を発現させないようにする

当たり前の話だと思いますが、SLAは、問題インスタンスが正常系に対して正常にレスポンスを返すことを確認する通信です。
よって、いくら決定的にふるまおうが、SLAが脆弱性を発現させることはあってはなりません。

しかし、意外と気を抜いていると、うっかり違反してしまいえる約束事ではあります。特にpwnの問題でうっかりbuffer overflowを踏んでしまうような、長い入力をしてしまうようなことは考えられるんじゃないでしょうか。実際、ICCにおいても、実は当日の朝にこのルールを満たしていないSLA scriptが見つかり、急ぎ修正を行ったりしました....

### 4.b. SLAの内容は漏洩してもいいようにする

最後に非常に重要かつ難しい項目になりますが、SLAの内容（送信される内容で合って、scriptの実装ではないことに注意）は、最悪ケースを考えた場合、漏洩・特定することは可能である、ということを理解すべきです。

どれだけ対策をしていても、ペナルティを覚悟で漏洩させようとすれば、内容を漏洩させることは可能であり、SLAの内容が特定されると破綻するような問題は作ってはいけません。

#### 失敗例 4.b.1. SLAの特定による問題の破綻

> dockerベースのA&Dの大会を、できるだけSLAが漏洩しないようなルールを設定した上で、開催した。
> 具体的には、運営から提供するパケットにはSLAは含めないようにしつつ、問題インスタンスから外部サーバーやWANへの接続は不可能にした。更には、問題インスタンスに届けられるパケットを匿名化し、TTLやRTTなど、識別に使えそうなパラメータをすべて無効化した。
> しかし、あるチームがSLAの特定に成功してしまった。そのチームは、問題インスタンスに届いたペイロードをすべて保存し、すべての接続に対して、最後に保存している内容を返送するようにした。
> 当然、これは期待されるレスポンスではないため、SLAとしてはfailする。しかし、運営から提供されるパケットにはSLAが含まれず、問題インスタンスが返送するレスポンスにはSLAを含むすべてのレスポンスが含まれる。よって、これらの差分を取ることで、具体的にSLAが何を送信しているのかを、SLA failのペナルティと引き換えに明らかにすることができる。
> 結果、この問題では作問者がSLAを手抜きしており、リクエストが固定値であることが判明し、そのチームは次のラウンドから、その固定値以外の入力をすべて弾くパッチを適用した。

このとおり、いくらペナルティを与えても、最悪ケースとして、SLAの内容の漏洩が起きえるということは理解しければなりません。
よって、SLAは、最低限、ありえる正常系の入力はすべて生成されるような分布でテストを行うべきですし、可能であれば、時間経過とともに分布が変化するなど、内容から分布の推定が難しいようなものを利用すべきです。

# ケーススタディ: ICC Tokyo 2025 CGI Panic

上記の注意事項を考慮したケーススタディとして、ICCにおいて私が出題した問題を見てみましょう。
この問題は、複数のCGIからなるpwnの問題です。
CGIを題材にした理由は以下のとおりです:

- 複数のCGIを提供することで、問題ボリュームや難易度の調整が非常に簡単になる
    - 更には、webの問題が不足、もしくは難易度が十分でない場合には、webのCGIも足せば、バランスを調整できる
- ICCは各チームのパッチが非公開である。上述のとおり、バイナリパッチを許可すると、リロケーションなどにより実質的にスーパーマンパッチが可能になる。バイナリパッチを不可能にしつつ、プレイヤーになるべくストレスがかからない方法でパッチさせることを考えると、WAFが最も適していると考えられる
    - バイナリパッチを可にしても不可にしてもゲームバランスが偏ることは懸念としてあったため、実際には、4個のCGIを提供した上で、そのうち2個をバイナリパッチ不可、残りの2個をバイナリパッチ可とした
- プレイヤーに不用意に強い権限を与えないためには、バイナリを実行する権限をできるだけ落としたいが、CGIはWebサーバーとプロセスが分かれていて、これを実現しやすい

4つのCGIは、3人の作問者で手分けして作成しましたが、私のCGIは以下のような設計にして、3.d., 3.e.などの性質も満たせるようにしています：

- リクエストの一部は、フラグのハッシュを鍵としてAESで暗号化される。結果として、パケットをローカルでリプレイしたところで、脆弱性を簡単に発現させることはできない
- 自前のヒープを実装したstaticなバイナリになっている。結果として、hardened mallocを適用することはできないし、heapの脆弱性を悪用できる
- shellcodeが実行できる設定になっていて、exploitできた場合は任意のコード実行が可能。よって、flagを出力する際に適当に暗号化すれば、パケット解析でバレることはない
- C++の巨大なバイナリになっており、relocationをするのは一定難しくしてある。また、デフォルトでは、rwxな領域を固定のアドレスにマップするため、バイナリ側をrelocationしていても、適切にパッチを当てない限りは、固定のアドレスを利用した攻撃が通る

# 最後に

いかがだったでしょうか。どの程度の人が、ここまでちゃんと読んだのかが気になるところですが、ひとまず、A&Dの問題を作成するには、これぐらい様々なケースを考えたほうがいいということが伝わっていれば幸いです。
ICCでは、主に私が、ステコミや他の作問者に対して口うるさく、ここまで書いたような懸念があることを主張してしました。
そのおかげか、どうにかこうにか、なるべく大きな問題は避けることができ、大会を無事にクローズすることができました。
これらの議論に参加し、ときには私のアドバイスに従ってくれたステコミのメンバーや他の作問者に対し、この場を借りて感謝を示したいと思います。

最後に、A&Dの問題を作ろうとしているあなたに、忠告をして終わりにしたいと思います。

- プレイヤーは、あなたが思っているほど真面目に問題を解く気はないし、あなたが想定していないしょうもないところに詰まり時間を溶かす
- プレイヤーは、あなたが思っているより数倍、不正を働くことにはやる気を出し、あなたが思っているより数倍、賢い方法で不正を働いてくる
- あなたの作ろうと思っている問題や脆弱性およびSLAは、あなたの想像以上に、色々な要因でうまくいかないし、ロバストでない
